#' This script assembles source files containing objects, methods, and
#' {roxygen2} documentation for {recipe} steps to perform vectorizations of
#' persistent homology provided by {TDAvec}.
#'
#' To generate or update these files, execute the following:
#' source(here::here("pre-generate/generate-steps.R"))
#' 
#' Refer to the following resources for guidance:
#' https://blog.r-hub.io/2020/02/10/code-generation/
#' https://www.tidymodels.org/learn/develop/recipes/

#' SETUP

#' Set build parameters.

# standard prefix for built files
build_prefix <- "zzz"

# warning not to edit by hand
build_warning <- glue::glue(
  "# --------------------------------------",
  "----------------------------------------\n",
  "# Generated by 'pre-generate/generate-steps.R': do not edit by hand.\n",
  "# --------------------------------------",
  "----------------------------------------\n\n\n",
)

# source building utilities
source(here::here("pre-generate/utils-generate.R"))

#' GENERATORS

#' Generate step documentation.

# format custom parameters for inclusion into step arguments and augment scale
# sequence parameters with scale sequence-generating parameters on one line
custom_params_leave <- function(args) {
  params <- unname(arg_params[args])
  lines <- params
  lines <- gsub(
    "([xy]{1})seq",
    paste0(
      vapply(c("seq", "min", "max", "len", "by"), \(s) paste0("\\1", s), ""),
      collapse = ", "
    ),
    lines
  )
  lines
}
custom_params_set <- function(fn, args) {
  params <- unname(arg_params[args])
  defaults <- subset(param_defaults, fun == fn, c(param, default)) |> deframe()
  lines <- paste0(params, " = ", defaults[params])
  # if no default provided, use `NULL`
  lines <- gsub(" NA$", " NULL", lines)
  lines <- gsub(
    "([xy]{1})seq = NULL",
    paste0(
      c("\\1seq", "\\1min", "\\1max", "\\1len", "\\1by"),
      " = NULL", collapse = ", "
    ),
    lines
  )
  lines
}
custom_params_pass <- function(args) {
  params <- unname(arg_params[args])
  lines <- paste0(params, " = ", params)
  lines <- gsub(
    "([xy]{1})seq = \\1seq",
    paste0(
      vapply(
        c("seq", "min", "max", "len", "by"),
        \(s) paste0("\\1", s, " = \\1", s),
        ""
      ),
      collapse = ", "
    ),
    lines
  )
  lines
}
custom_params_elt <- function(args) {
  lines <- custom_params_pass(args)
  lines <- gsub(" = ", " = x\\$", lines)
  lines
}
custom_params_compute <- function(args) {
  params <- unname(arg_params[args])
  lines <- paste0(args, " = object$", params)
  lines
}
# custom_params_leave(c("homDim", "scaleSeq", "tau"))
# custom_params_set("computeVPB", c("homDim", "scaleSeq", "tau"))
# custom_params_pass(c("homDim", "scaleSeq", "tau"))
# custom_params_elt(c("homDim", "scaleSeq", "tau"))
# custom_params_compute(c("homDim", "scaleSeq", "tau"))

# preprocessing code for common parameters
param_preprocesses <- list(
  # no pre-processing for homological degree (defalts to `0L`)
  hom_degree = c(),
  # if maximum degree is not specified, use the maximum data dimension
  max_hom_degree = c(
    "if (x$max_hom_degree == Inf)",
    "  x$max_hom_degree <-",
    "    get_max_hom_degree(training[, col_names, drop = FALSE])"
  ),
  # reconcile scale sequence parameters
  xseq = c(
    "x[paste0(\"x\", c(\"seq\", \"min\", \"max\", \"len\", \"by\"))] <- ",
    "  reconcile_scale_seq(x, training[, col_names, drop = FALSE], \"x\")"
  ),
  yseq = c(
    "x[paste0(\"y\", c(\"seq\", \"min\", \"max\", \"len\", \"by\"))] <- ",
    "  reconcile_scale_seq(x, training[, col_names, drop = FALSE], \"y\")"
  )
  # # TODO: pre-process remaining parameters
  # # ComplexPolynomial
  # num_coef = c(),
  # poly_type = c(),
  # # PersistenceBlock
  # # calibrate to PD range
  # block_size = c(),
  # # PersistenceImage
  # # calibrate to PD range
  # img_sigma = c(),
  # # PersistenceLandscape
  # # calibrate to number of levels
  # num_levels = c(),
  # generalized = c(),
  # # calibrate to PD range
  # weight_func_pl = c(),
  # bandwidth = c(),
  # # PersistenceSilhouette
  # weight_power = c(),
  # # TemplateFunction
  # tent_size = c(),
  # num_bins = c(),
  # tent_shift = c(),
  # # TropicalCoordinates
  # # calibrate to PD size
  # num_bars = c()
)

# generate title and description
build_title_descr <- function(fn) {
  fn_sname <- vec_sname(fn)
  fn_title <- tdavec_renames |> 
    filter(name == fn) |> 
    pull(rename) |> 
    snakecase::to_title_case() |> 
    paste("Vectorization of Persistent Homology")
  fn_title_doc <- paste0("@title ", fn_title)
  fn_descr <- c(
    paste0("@description The function `step_vpd_", fn_sname, "()` creates"),
    "  a _specification_ of a recipe step that will convert",
    "  a list-column of 3-column matrices of persistence data",
    "  to a list-column of 1-row matrices of vectorizations."
  )
  
  c(fn_title_doc, "", fn_descr, "") |> 
    doc_wrap() |> 
    as.list() |> c(list("\n\n")) |> 
    do.call(what = glue::glue)
}
# build_title_descr("computeNormalizedLife")
# build_title_descr("computeTropicalCoordinates")

# generate details
build_details <- function(fn) {
  fn_sname <- vec_sname(fn)
  fn_name <- tdavec_renames |> 
    filter(name == fn) |> 
    pull(rename) |> 
    snakecase::to_title_case() |> 
    tolower() |> capitalize_proper_names()
  fn_line <- c(
    paste0("The ", fn_name, " vectorization deploys"),
    paste0(link_obj(fn), "."),
    "See there for definitions and references."
  )
  fn_args <- tdavec_functions |> 
    filter(name == fn) |> 
    pull(args) |> first() |> names() |> setdiff("D")
  fn_dials <- arg_params[fn_args] |> 
    gsub(pattern = "([xy]{1})seq", replacement = "\\1seq|\\1other") |> 
    strsplit("\\|") |> unlist() |> unname() |> 
    # FIXME: Enable tuning by resolution.
    setdiff(c("xseq", "xother", "yseq", "yother")) |> 
    intersect(param_tuners)
  fn_bullets <- dial_titles[fn_dials] |> 
    gsub(pattern = "Number of ", replacement = "# ") |> 
    gsub(pattern = "\\?$", replacement = "")
  fn_type <- dial_types[fn_dials]
  fn_defaults <- param_defaults |> 
    subset(fun == fn, c(param, default)) |> 
    deframe() |> 
    (\(x) x[fn_dials])()
  
  fn_tunables <- paste0(
    "This step has ", length(fn_dials),
    " tuning parameter", if (length(fn_dials) > 1L) "s", ":"
  )
  fn_tunings <- paste0(
    "  \\item `", fn_dials, "`: ", fn_bullets,
    " (type: ", fn_type, ", default: `", fn_defaults, "`)"
  )
  
  c(
    "",
    "@template step-vpd-details",
    "",
    "@section Engine:",
    "",
    fn_line,
    "",
    # "\\describe{{}}",
    # "",
    "@section Tuning Parameters:",
    "",
    fn_tunables,
    "\\itemize{{",
    fn_tunings,
    "}}",
    ""
  ) |> 
    doc_wrap() |> 
    as.list() |> c(list("\n")) |> 
    do.call(what = glue::glue)
}
# build_details("computePersistenceImage")

# generate parameter documentation
build_param_docs <- function(fn) {
  fn_sname <- vec_sname(fn)
  fn_args <- tdavec_functions |> 
    filter(name == fn) |> 
    pull(args) |> first() |> names() |> setdiff("D")
  fn_dials <- arg_params[fn_args] |> 
    gsub(pattern = "([xy]{1})seq", replacement = "\\1seq|\\1other") |> 
    strsplit("\\|") |> unlist() |> unname()
  fn_param_docs <- mapply(
    \(p, d) c(paste0("@param ", p, "\n", d[1L]), d[-1L]),
    p = gsub("([xy]{1})other", "\\1min,\\1max,\\1len,\\1by", fn_dials),
    d = param_docs[fn_dials]
  ) |> 
    unname() |> unlist() |> 
    # replace any placeholders with `@inheritParams` tags
    gsub(
      pattern = "^@param [A-Za-z0-9\\_]+\n([A-Za-z0-9\\.]+::[A-Za-z0-9\\_]+)",
      replacement = "@inheritParams \\1"
    ) |> 
    unique() |> 
    strsplit("\n *") |> unlist() |> 
    gsub(pattern = "^([^@]+)", replacement = "  \\1") |> 
    doc_wrap() |> as.list() |> c(list("\n\n"))
  
  do.call(what = glue::glue, args = fn_param_docs)
}
# build_param_docs("computePersistenceLandscape")

# generate importation and inheritance instructions
# (include argument for `do.call()` in source code generation)
build_import_inherit <- function(fn) {
  glue::glue(
    doc_wrap("@import recipes"),
    doc_wrap("@inheritParams recipes::step_pca"),
    doc_wrap("@inherit recipes::step_pca return"),
    "\n"
  )
}
# build_import_inherit()

# generate link to example file
build_ex <- function(fn) {
  fn_hname <- gsub("\\_", "-", vec_sname(fn))
  fn_line <- 
    glue::glue("@example inst/examples/{build_prefix}-ex-step-vpd-{fn_hname}.R")
  
  glue::glue(doc_wrap(fn_line), "\n\n")
}
# build_ex("computePersistenceSilhouette")

#' Generate step functions.

# generate `step_*()`
build_step <- function(fn) {
  fn_sname <- vec_sname(fn)
  fn_args <- tdavec_functions |> 
    filter(name == fn) |> 
    pull(args) |> first() |> names() |> setdiff("D")
  fn_set <- paste0(
    "    ", custom_params_set(fn, fn_args), ",\n",
    collapse = ""
  )
  fn_pass <- paste0(
    "      ", custom_params_pass(fn_args), ",\n",
    collapse = ""
  )
  
  # TODO: Can't this be done using `paste0()`?
  glue::glue(
    doc_wrap("@export"),
    "step_vpd_{fn_sname} <- function(\n",
    "    recipe,\n",
    "    ...,\n",
    # standard inputs
    "    role = \"predictor\",\n",
    "    trained = FALSE,\n",
    # custom parameters
    "{fn_set}",
    # standard parameters
    "    columns = NULL,\n",
    "    keep_original_cols = TRUE,\n",
    "    skip = FALSE,\n",
    "    id = rand_id(\"vpd_{fn_sname}\")\n",
    ") {{\n",
    # ensure that required packages are installed
    "  recipes_pkg_check(required_pkgs.step_vpd_{fn_sname}())\n",
    "  \n",
    # output the step addition
    "  add_step(\n",
    "    recipe,\n",
    "    step_vpd_{fn_sname}_new(\n",
    "      terms = rlang::enquos(...),\n",
    "      trained = trained,\n",
    "      role = role,\n",
    "{fn_pass}",
    "      columns = columns,\n",
    "      keep_original_cols = keep_original_cols,\n",
    "      skip = skip,\n",
    "      id = id\n",
    "    )\n",
    "  )\n",
    "}}\n",
    "\n\n"
  )
}
# build_step("computePersistenceBlock")

# generate `step_*_new()`
build_step_new <- function(fn) {
  fn_sname <- vec_sname(fn)
  fn_args <- tdavec_functions |> 
    filter(name == fn) |> 
    pull(args) |> first() |> names() |> setdiff("D")
  fn_leave <- paste0(
    "    ", custom_params_leave(fn_args), ",\n",
    collapse = ""
  )
  fn_pass <- paste0(
    "    ", custom_params_pass(fn_args), ",\n",
    collapse = ""
  )
  
  glue::glue(
    "step_vpd_{fn_sname}_new <- function(\n",
    # standard inputs
    "    terms,\n",
    "    role, trained,\n",
    # custom parameters
    "{fn_leave}",
    # standard parameters
    "    columns, keep_original_cols,\n",
    "    skip, id\n",
    ") {{\n",
    # output the step
    "  step(\n",
    "    subclass = \"vpd_{fn_sname}\",\n",
    "    terms = terms,\n",
    "    role = role,\n",
    "    trained = trained,\n",
    "{fn_pass}",
    "    columns = columns,\n",
    "    keep_original_cols = keep_original_cols,\n",
    "    skip = skip,\n",
    "    id = id\n",
    "  )\n",
    "}}\n",
    "\n\n"
  )
}
# build_step_new("computePersistentEntropy")

# generate `prep.step_vpd_*()`
build_prep <- function(fn) {
  fn_sname <- vec_sname(fn)
  fn_args <- tdavec_functions |> 
    filter(name == fn) |> 
    pull(args) |> first() |> names() |> setdiff("D")
  fn_elt <- paste0(
    "    ", custom_params_elt(fn_args), ",\n",
    collapse = ""
  )
  fn_preproc1 <- param_preprocesses[arg_params[fn_args]] |> 
    lapply(\(v) c(v, "")) |> 
    setdiff(list("")) |> 
    unlist() |> unname() |> 
    (\(l) paste0("  ", l, "\n", collapse = ""))()
  fn_name <- gsub("^compute", "", fn)
  fn_preproc2 <- if (! fn_name %in% names(tdavec_preps)) "" else 
    tdavec_preps[[fn_name]] |> 
    deparse() |> 
    (\(s) s[seq(2L, length(s) - 1L)])() |> 
    gsub("^  ", "", x = _) |> 
    (\(s) paste0(s, "\n", collapse = ""))() |> paste0("\n")
  
  glue::glue(
    doc_wrap("@export"),
    "prep.step_vpd_{fn_sname} <- function(x, training, info = NULL, ...) {{\n",
    # extract columns and ensure they are lists of 3-column numeric tables
    "  col_names <- recipes_eval_select(x$terms, training, info)\n",
    # ensure that columns are list-columns of 3-column persistence diagrams
    "  check_pd_list(training[, col_names, drop = FALSE])\n",
    # TODO: Delete this conversion here if not needed below.
    # remove troublesome 'AsIs' class (and any other non-'list' classes)
    "  for (col_name in col_names) class(training[[col_name]]) <- \"list\"\n",
    "  \n",
    "{fn_preproc1}",
    "{fn_preproc2}",
    # output prepped step
    "  step_vpd_{fn_sname}_new(\n",
    "    terms = col_names,\n",
    "    role = x$role,\n",
    "    trained = TRUE,\n",
    "{fn_elt}",
    "    columns = col_names,\n",
    "    keep_original_cols = get_keep_original_cols(x),\n",
    "    skip = x$skip,\n",
    "    id = x$id\n",
    "  )\n",
    "}}\n",
    "\n\n"
  )
}
# build_prep("computePersistenceLandscape")

# generate `bake.step_vpd_*()`
build_bake <- function(fn) {
  fn_sname <- vec_sname(fn)
  fn_abbr <- tolower(gsub("[a-z]", "", fn))
  fn_args <- tdavec_functions |> 
    filter(name == fn) |> 
    pull(args) |> first() |> names() |> setdiff("D")
  fn_compute <- paste0(
    "          ", custom_params_compute(fn_args), "",
    collapse = ",\n"
  ) |> paste0("\n")
  
  glue::glue(
    doc_wrap("@export"),
    "bake.step_vpd_{fn_sname} <- function(object, new_data, ...) {{\n",
    "  col_names <- names(object$columns)\n",
    "  check_new_data(col_names, object, new_data)\n",
    # remove troublesome 'AsIs' class (and any other non-'list' classes)
    "  for (col_name in col_names) class(new_data[[col_name]]) <- \"list\"\n",
    "  \n",
    # tabulate vectorizations of each persistence data column
    "  vph_data <- tibble::tibble(.rows = nrow(new_data))\n",
    # TODO: compare with existing recipes and decide to store vectorizations as
    # * matrices in list columns (with or without names)
    # * data frames in list columns (require names)
    # * numerous additional columns (require names)
    "  for (col_name in col_names) {{\n",
    "    col_vpd <- purrr::map(\n",
    "      new_data[[col_name]],\n",
    "      function(d) {{\n",
    "        v <- TDAvec::{fn}(\n",
    "          as.matrix(d),\n",
    "{fn_compute}",
    "        )\n",
    "        vn <- vpd_suffix(v)\n",
    "        v <- as.vector(v)\n",
    "        names(v) <- vn\n",
    "        v\n",
    "      }}\n",
    "    )\n",
    # col_vpd <- lapply(col_vpd, matrix, nrow = 1L)\n",
    "    col_vpd <- purrr::map(\n",
    "      col_vpd,\n",
    "      function(v) as.data.frame(matrix(\n",
    "        v, nrow = 1L, dimnames = list(NULL, names(v))\n",
    "      ))\n",
    "    )\n",
    "    vph_data[[paste(col_name, \"{fn_abbr}\", sep = \"_\")]] <- col_vpd\n",
    "  }}\n",
    # unnest data-framed matrices to ensure commensurate columns
    "  vph_data <- tidyr::unnest(\n",
    "    vph_data,\n",
    "    cols = tidyr::all_of(paste(col_names, \"{fn_abbr}\", sep = \"_\")),\n",
    "    names_sep = \"_\"\n",
    "  )\n",
    "  \n",
    "  check_name(vph_data, new_data, object)\n",
    "  new_data <- vctrs::vec_cbind(new_data, vph_data)\n",
    "  new_data <- remove_original_cols(new_data, object, col_names)\n",
    "  new_data\n",
    "}}\n",
    "\n\n"
  )
}
# build_bake("computeEulerCharacteristic")

# generate `print.step_vpd_*()`
build_print <- function(fn) {
  fn_sname <- vec_sname(fn)
  fn_name <- tdavec_renames |> 
    filter(name == fn) |> 
    pull(rename) |> 
    snakecase::to_title_case() |> 
    tolower() |> capitalize_proper_names()
  
  glue::glue(
    doc_wrap("@export"),
    "print.step_vpd_{fn_sname} <- function(\n",
    "    x, width = max(20, options()$width - 35), ...\n",
    ") {{\n",
    "  title <- \"{fn_name} of \"\n",
    "  \n",
    "  print_step(\n",
    # names before prep (could be selectors)
    "    untr_obj = x$terms,\n",
    # names after prep
    "    tr_obj = NULL,\n",
    # whether recipe has been prepped
    "    trained = x$trained,\n",
    # what the recipe does
    "    title = title,\n",
    # estimated number of characters to print per line
    "    width = width\n",
    "  )\n",
    "  invisible(x)\n",
    "}}\n",
    "\n\n"
  )
}
# build_print("computePersistentEntropy")

# generate `required_pkgs.step_vpd_*()`
build_req <- function(fn) {
  fn_sname <- vec_sname(fn)
  
  glue::glue(
    doc_wrap("@rdname required_pkgs.tdarec"),
    doc_wrap("@export"),
    "required_pkgs.step_vpd_{fn_sname} <- function(x, ...) {{\n",
    "  c(\"TDAvec\", \"tdarec\")\n",
    "}}\n",
    "\n\n"
  )
}
# build_req("computeComplexPolynomial")

# generate `tidy.step_vpd_*()`
build_tidy <- function(fn) {
  fn_sname <- vec_sname(fn)
  
  glue::glue(
    doc_wrap("@rdname step_vpd_{fn_sname}"),
    doc_wrap("@usage NULL"),
    doc_wrap("@export"),
    "tidy.step_vpd_{fn_sname} <- function(x, ...) {{\n",
    "  if (is_trained(x)) {{\n",
    "    res <- tibble::tibble(\n",
    "      terms = unname(x$columns),\n",
    "      value = rep(NA_real_, length(x$columns))\n",
    "    )\n",
    "  }} else {{\n",
    "    term_names <- sel2char(x$terms)\n",
    "    res <- tibble::tibble(\n",
    "      terms = term_names,\n",
    "      value = rep(NA_real_, length(term_names))\n",
    "    )\n",
    "  }}\n",
    "  res$id <- x$id\n",
    "  res\n",
    "}}\n",
    "\n\n"
  )
}
# build_tidy("computeTropicalCoordinates")

# generate `tunable.step_vpd_*()`
build_tunable <- function(fn) {
  fn_sname <- vec_sname(fn)
  fn_args <- tdavec_functions |> 
    filter(name == fn) |> 
    pull(args) |> first() |> names() |> setdiff("D")
  fn_dials <- arg_params[fn_args] |> 
    gsub(pattern = "([xy]{1})seq", replacement = "\\1seq|\\1other") |> 
    strsplit("\\|") |> unlist() |> unname() |> 
    # FIXME: Enable tuning by resolution.
    setdiff(c("xseq", "xother", "yseq", "yother")) |> 
    intersect(param_tuners)
  fn_ranges_values <- dial_ranges_values[fn_dials] |> 
    lapply(\(x) vapply(x, deparse, "")) |> 
    lapply(\(x) ifelse(grepl("^NA\\_", x), "unknown()", x)) |> 
    sapply(paste0, collapse = ", ")
  fn_param_class <- type_class[dial_types[fn_dials]] |> unname()
  fn_scope_param <- c(quant = "range", qual = "values")[fn_param_class]
  fn_params_string <- paste0("\"", paste0(fn_dials, collapse = "\", \""), "\"")
  fn_dials_set <- ! is.na(fn_scope_param)
  fn_dials_string <- paste0(
    "      list(pkg = \"tdarec\", fun = \"",
    fn_dials[fn_dials_set],
    "\", ", fn_scope_param[fn_dials_set], " = c(",
    fn_ranges_values[fn_dials_set],
    "))",
    collapse = ",\n"
  )
  
  glue::glue(
    doc_wrap("@rdname tunable_tdavec"),
    doc_wrap("@export"),
    "tunable.step_vpd_{fn_sname} <- function(x, ...) {{\n",
    "  tibble::tibble(\n",
    # argument name
    "    name = c({fn_params_string}),\n",
    # dial generators
    "    call_info = list(\n",
    "{fn_dials_string}\n",
    "    ),\n",
    # source of tuning value
    "    source = \"recipe\",\n",
    # sub-source of tuning value
    "    component = \"step_vpd_{fn_sname}\",\n",
    # unique identifier
    "    component_id = x$id\n",
    "  )\n",
    "}}\n",
    "\n\n"
  )
}
# build_tunable("computeBettiCurve")
# build_tunable("computePersistenceLandscape")
# build_tunable("computeTemplateFunction")

#' WRITING

#' Write step source code.

for (fn in tdavec_functions$name) {
  fn_hname <- gsub("\\_", "-", vec_sname(fn))
  
  # initialize file
  step_file <- here::here(glue::glue("R/{build_prefix}-step-vpd-{fn_hname}.R"))
  cat(build_warning, file = step_file, append = FALSE)
  
  # populate with elements
  list(
    build_title_descr,
    build_details,
    build_param_docs,
    build_import_inherit,
    build_ex,
    build_step,
    build_step_new,
    build_prep,
    build_bake,
    build_print,
    build_req,
    build_tidy,
    build_tunable
  ) |> 
    lapply(do.call, args = list(fn = fn)) |> 
    lapply(cat, file = step_file, append = TRUE)
}

#' Write examples.

# example parameter passes
ex_param_vals <- c(
  hom_degree = 1L,
  max_hom_degree = 2L,
  xmax = "max_death",
  xby = .01,
  ymax = "max_persistence",
  yby = .01,
  img_sigma = 1,
  num_levels = 3,
  dist_power = 2,
  block_size = 1
)

# write example files from template (overwrites existing files)
for (fn in tdavec_functions$name) {
  fn_sname <- vec_sname(fn)
  fn_hname <- gsub("\\_", "-", fn_sname)
  fn_args <- tdavec_functions |> 
    filter(name == fn) |> 
    pull(args) |> first() |> names() |> setdiff("D")
  fn_params <- arg_params[fn_args] |> 
    gsub(pattern = "([xy]{1})seq", replacement = "\\1seq|\\1other") |> 
    strsplit("\\|") |> unlist() |> unname() |> 
    intersect(names(ex_param_vals))
  fn_param_vals <- 
    paste0(fn_params, " = ", ex_param_vals[fn_params], collapse = ", ")
  
  glue::glue("inst/examples/{build_prefix}-ex-step-vpd-{fn_hname}.R") |> 
    here::here() ->
    ex_file
  cat("", file = ex_file, append = FALSE)
  
  readLines("man/template/template-ex-step-vpd2.R") |> 
    gsub(pattern = "step_vpd_", replacement = paste0("step_vpd_", fn_sname)) |> 
    gsub(pattern = "\\{param_vals\\}", replacement = fn_param_vals) |> 
    write(file = ex_file, append = TRUE)
}

#' Write unit tests.

# test parameter passes
test_param_vals <- c(
  hom_degree = 0L,
  max_hom_degree = 0L,
  img_sigma = 10,
  num_levels = 3L,
  dist_power = 2,
  block_size = .5,
  tent_size = 1000L,
  num_bins = 5L,
  tent_shift = 100L
)

# rm appropriate lines from template (as vector of character strings)
keep_scales <- function(x, scales) {
  rm_lines <- switch(
    scales,
    none = grepl("(x|y|scale)Seq|(x|y)seq", x),
    x = grepl("(x|y)Seq|yseq", x),
    xy = grepl("scaleSeq", x)
  )
  x[! rm_lines]
}
# write test files from template (overwrites existing files)
for (fn in tdavec_functions$name) {
  fn_sname <- vec_sname(fn)
  fn_hname <- gsub("\\_", "-", fn_sname)
  fn_args <- tdavec_functions |> 
    filter(name == fn) |> 
    pull(args) |> first() |> names() |> setdiff("D")
  fn_scales <- if ("scaleSeq" %in% fn_args) {
    "x"
  } else if (all(c("xSeq", "ySeq") %in% fn_args)) {
    "xy"
  } else {
    "none"
  }
  fn_test_params <- arg_params[fn_args] |> 
    gsub(pattern = "([xy]{1})seq", replacement = "\\1seq|\\1other") |> 
    strsplit("\\|") |> unlist() |> unname() |> 
    intersect(names(test_param_vals))
  fn_param_vals <- 
    paste0(fn_test_params, " = ", test_param_vals[fn_test_params], collapse = ", ")
  fn_arg_vals <- param_args[fn_test_params] |> 
    paste0(" = ", test_param_vals[fn_test_params], collapse = ", ")
  fn_params <- arg_params[fn_args] |> 
    gsub(pattern = "([xy]{1})seq", replacement = "\\1seq|\\1other") |> 
    strsplit("\\|") |> unlist() |> unname() |> 
    intersect(param_tuners) |> deparse()
  
  glue::glue("tests/testthat/test-{build_prefix}-step-vpd-{fn_hname}.R") |> 
    here::here() ->
    test_file
  cat(build_warning, file = test_file, append = FALSE)
  
  readLines("man/template/template-test-step-vpd.R") |> 
    gsub(pattern = "\\{orig_fun\\}", replacement = fn) |> 
    gsub(pattern = "step_vpd_", replacement = paste0("step_vpd_", fn_sname)) |> 
    gsub(pattern = "\\{param_vals\\}", replacement = fn_param_vals) |> 
    gsub(pattern = "\\{arg_vals\\}", replacement = fn_arg_vals) |> 
    gsub(pattern = "\\{fun_params\\}", replacement = fn_params) |> 
    keep_scales(scales = fn_scales) |> 
    write(file = test_file, append = TRUE)
}
